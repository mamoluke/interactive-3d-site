<!DOCTYPE html>
<html>
<head>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { width: 100%; height: 100% }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.157.0/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/ammo.js@0.0.10/ammo.min.js"></script>
    <script>
        let physicsWorld;
        let scene, camera, renderer;
        let rigidBodies = [];
        let tmpTrans;

        Ammo().then(start);

        function start() {
            tmpTrans = new Ammo.btTransform();
            setupGraphics();
            setupPhysics();
            createObjects();
            animate();
        }

        function setupGraphics() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.2, 5000);
            camera.position.set(0, 30, 70);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(-10, 30, 20);
            scene.add(light);
            scene.add(new THREE.AmbientLight(0x707070));
        }

        function setupPhysics() {
            const collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
            const dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
            const broadphase = new Ammo.btDbvtBroadphase();
            const solver = new Ammo.btSequentialImpulseConstraintSolver();
            physicsWorld = new Ammo.btDiscreteDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration);
            physicsWorld.setGravity(new Ammo.btVector3(0, -9.8, 0));
        }

        function createObjects() {
            // 床
            const pos = { x: 0, y: -2, z: 0 };
            const scale = { x: 50, y: 2, z: 50 };
            const mass = 0;

            const floor = new THREE.Mesh(
                new THREE.BoxGeometry(scale.x, scale.y, scale.z),
                new THREE.MeshPhongMaterial({ color: 0x808080 })
            );
            floor.position.set(pos.x, pos.y, pos.z);
            scene.add(floor);

            const transform = new Ammo.btTransform();
            transform.setIdentity();
            transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
            const motionState = new Ammo.btDefaultMotionState(transform);
            const colShape = new Ammo.btBoxShape(new Ammo.btVector3(scale.x * 0.5, scale.y * 0.5, scale.z * 0.5));
            const rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, colShape, new Ammo.btVector3(0, 0, 0));
            const body = new Ammo.btRigidBody(rbInfo);
            physicsWorld.addRigidBody(body);

            // 球体
            for (let i = 0; i < 20; i++) {
                const radius = 1;
                const sphere = new THREE.Mesh(
                    new THREE.SphereGeometry(radius),
                    new THREE.MeshPhongMaterial({ color: Math.random() * 0xffffff })
                );
                sphere.position.set(
                    Math.random() * 10 - 5,
                    20 + i * 2,
                    Math.random() * 10 - 5
                );
                scene.add(sphere);

                const sphereTransform = new Ammo.btTransform();
                sphereTransform.setIdentity();
                sphereTransform.setOrigin(new Ammo.btVector3(sphere.position.x, sphere.position.y, sphere.position.z));
                const sphereMotionState = new Ammo.btDefaultMotionState(sphereTransform);
                const sphereShape = new Ammo.btSphereShape(radius);
                const sphereMass = 1;
                const localInertia = new Ammo.btVector3(0, 0, 0);
                sphereShape.calculateLocalInertia(sphereMass, localInertia);
                const sphereRbInfo = new Ammo.btRigidBodyConstructionInfo(sphereMass, sphereMotionState, sphereShape, localInertia);
                const sphereBody = new Ammo.btRigidBody(sphereRbInfo);
                physicsWorld.addRigidBody(sphereBody);
                rigidBodies.push({ mesh: sphere, body: sphereBody });
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            const deltaTime = 1 / 60;
            physicsWorld.stepSimulation(deltaTime, 10);

            for (let i = 0; i < rigidBodies.length; i++) {
                const objThree = rigidBodies[i].mesh;
                const objAmmo = rigidBodies[i].body;
                const ms = objAmmo.getMotionState();
                if (ms) {
                    ms.getWorldTransform(tmpTrans);
                    const p = tmpTrans.getOrigin();
                    const q = tmpTrans.getRotation();
                    objThree.position.set(p.x(), p.y(), p.z());
                    objThree.quaternion.set(q.x(), q.y(), q.z(), q.w());
                }
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', function () {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html><!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="UTF-8">
 <meta name="viewport" content="width=device-width, initial-scale=1.0">
 <title>Collision Simulation</title>
 <link rel="stylesheet" href="css/style.css">
</head>
<body>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.157.0/three.min.js"></script>
 <script src="https://cdn.jsdelivr.net/npm/ammo.js@0.0.10/ammo.min.js"></script>
 <script src="js/script.js"></script>
</body>
</html>
